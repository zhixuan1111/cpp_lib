# 堆排序总结

## **核心思路**
堆排序的核心是利用大顶堆（或小顶堆）的特性，其核心步骤可概括为：**建堆→取顶→调堆→重复**，具体步骤如下：
1. **构建大顶堆**：  
    - 将待排序数组转换为大顶堆（父节点值 ≥ 子节点值），使堆顶元素为整个数组的最大值。
    - 该操作在两个阶段发挥作用：一是排序初始阶段用于将原始数组构建为完整的大顶堆；二是在每次提取堆顶最大值后，由于堆顶与末尾元素交换破坏了堆的结构特性，需通过此操作重新维护剩余元素的大顶堆性质。
2. **提取最大值并调整堆**：
   - 将堆顶（最大值）与当前堆的最后一个元素交换，此时最大值被放到数组末尾（完成排序）。
   - 缩小堆的范围（排除已排序的末尾元素），对新的堆顶执行**堆化（heapify）** 操作，恢复大顶堆性质。
3. **重复步骤2**：直到堆的范围缩小至1，整个数组排序完成。


## **关键知识点**

### 1. **堆的定义与性质**
- **堆是完全二叉树**：除最后一层外，所有层均被填满；最后一层的节点从左到右连续排列。
- **大顶堆**：每个父节点的值 ≥ 左右子节点的值（堆顶为最大值）。
- **小顶堆**：每个父节点的值 ≤ 左右子节点的值（堆顶为最小值）。
- **节点索引关系**（假设数组下标从0开始）：
  - 左子节点索引 = 2×父节点索引 + 1
  - 右子节点索引 = 2×父节点索引 + 2
  - 父节点索引 = (子节点索引 - 1) // 2（整数除法）

### 2. **堆化（heapify）操作**
- **作用**：当某个节点破坏了堆的性质（如小于子节点），通过交换和递归调整，使以该节点为根的子树重新成为大顶堆。
- **过程**：
  1. 比较当前节点与左右子节点，找出最大值的索引。
  2. 若最大值不是当前节点，交换两者位置。
  3. 对交换后的值所在的子树递归执行堆化，直至子树满足堆性质。
- **终止条件**：当前节点已是其子树中的最大值，或递归到叶子节点（无有效子节点）。

### 3. **构建大顶堆的方法**
- 从**最后一个非叶子节点**开始（索引 = n//2 - 1，n为数组长度），依次向前对每个节点执行堆化操作。
- 原因：叶子节点本身已是 trival 堆（无子女），从非叶子节点开始可确保所有子树逐步满足堆性质。

### 4. **时间复杂度**
- **构建堆**：O(n)（并非O(n log n)，因底层节点堆化次数少）。
- **堆化操作**：每次堆化的时间复杂度为O(log n)（树的高度）。
- **总时间复杂度**：O(n log n)（构建堆O(n) + n-1次堆化O(n log n)）。

### 5. **空间复杂度**
- 原地排序（in-place），仅需O(1)的额外空间（递归实现的栈空间可忽略，或用迭代实现消除）。

### 6. **适用场景**
- 适合大规模数据排序，时间复杂度稳定（最坏情况仍为O(n log n)）。
- 不适合对已排序或接近排序的数据（无优化空间）。

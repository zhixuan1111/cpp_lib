# 说明
根据简历中提到的知识点自己实现一番，并且将**相应的知识点**和**常见面试问题**进行总结。主要分为八个部分，算法、容器、C++新特性、设计模式、并发组件、计算机网络、数据库、常用开发工具命令。最后总结成一个综合性的文档，用于面试辅助。
# 一、算法
## 1.1 查找算法：
- 二分查找：✅
- 线性查找：✅
## 1.2 排序算法
- 冒泡排序：✅
- 快速排序：✅
- 归并排序：✅
- 堆排序
## 1.3 二叉树
# 二、容器
## 2.1 vector：✅
### 2.1.1 vector实现方式
1. vector是一个函数模板类，内部由`T* data`，`size_t capacity`，`size_t size`组成，三个参数的含义分别是：
    - `data`：管理`T`类型的一块内存地址，大小为`capacity`；
    - `size`：当前数组中存放的元素个数。
2. 构造函数实现
    - `vector()`：默认构造函数。构造一个空的 vector，不包含任何元素。
    - `vector(size_t size)`：指定大小的构造函数。构造一个包含 n 个元素的 vector，每个元素使用默认值初始化（对于基本类型通常是 0）。
    - `vector(size_t size,T value)`：指定大小和初始值的构造函数。构造一个包含 n 个元素的 vector，每个元素都被初始化为指定值 value。
    - 还有迭代器范围构造函数、拷贝构造函数、移动构造函数（C++11 起）、初始化列表构造函数、分配器构造函数
### 2.1.2 vector相关面试问题
1. `vector`的扩容机制是什么？
    - `vector` 底层使用连续的动态数组存储元素，当现有容量不足以容纳新元素时，会触发扩容
    - 分配一块更大的新内存（通常是当前容量的 1.5~2 倍）
    - 将旧内存中的元素复制 / 移动到新内存
    - 释放旧内存
    - 指向旧内存的迭代器、指针、引用会失效
1. `push_back()`和`emplace_back()`有什么区别？`emplace_back()`是怎么实现的？
    - `push_back()`：
        用于将一个已经构造好的对象复制或移动到容器中。
        如果传入的是临时对象，会先构造临时对象，再通过移动构造函数将其移动到容器（C++11 及以后）；如果传入的是已有对象，则会调用复制构造函数。
    - `emplace_back()`：
        直接在容器的内存空间中原地构造对象，避免了临时对象的创建和移动 / 复制操作。
        它接收的是对象构造函数的参数，而非对象本身，通过这些参数直接在容器末尾构造新元素。
## 2.2 list：✅
## 2.3 hash table：✅
## 2.4 deque

# 三、C++新特性
需要了解的新特性有智能指针、`lambada`表达式
## 3.1 智能指针
### 3.1.1 unique_ptr

### 3.1.2 shared_ptr
1. **核心特点**
- 共享所有权。多个 `shared_ptr` 可以指向同一块动态分配的内存，内部通过引用计数（reference count）机制跟踪有多少个指针共享该资源。当最后一个指向该资源的 shared_ptr 被销毁或重置时，内存会自动释放。
2. **简易实现**
- `T* ptr`：指向实际管理的对象（原始指针）
- `size_t* ref_count`：指向一个整数的指针，用于记录当前有多少SharedPtr 实例在共享 ptr 指向的对象
- `shared_ptr(T *p)`：默认构造函数
- `shared_ptr(const shared_ptr &other)`：拷贝构造函数
- `shared_ptr(shared_ptr &&other)`：移动构造函数
- `~shared_ptr()`：析构函数
-  `shared_ptr &operator=(const shared_ptr &other)`：拷贝赋值运算符函数
- `shared_ptr &operator=(shared_ptr &&other)`：移动赋值运算符函数
- `T &operator*()`：重载解引用
- `T *operator->()`：重载`->`
3. **线程安全问题**
- **部分线程安全**：标准库的 `std::shared_ptr` 保证引用计数的修改是原子操作（线程安全），**但对管理的对象本身不提供线程安全**(指的是`T* ptr`),需要用户自己保证对象的线程安全。
- **非线程安全**：简单实现可能不保证引用计数的线程安全，多线程环境下操作同一个 `shared_ptr` 可能导致计数错乱。

### 3.1.3 make_shared
`make_shared` 属于 C++ 智能指针体系的一部分，它是一个函数模板，主要用于创建 `std::shared_ptr` 智能指针。具体来说有以下几个核心作用：
1. **内存管理更高效**：`make_shared` 会**一次性分配一块内存**，同时存储对象本身和引用计数，而单独使用 `new` 配合 `std::shared_ptr` 构造函数需要两次内存分配（一次给对象，一次给引用计数），因此 `make_shared` 能减少内存分配开销。
- **传统方式（`new` + `shared_ptr`）**：两次分配是独立的，操作系统需要分别处理两次内存申请，每次都要在内存管理系统中查找可用内存块、更新内存分配表等。
  - 第一次：通过 `new T(args)` 为对象本身分配内存（存储 `T` 类型的实例数据）。
  - 第二次：`shared_ptr` 内部需要为 "引用计数"（记录指针被多少个 `shared_ptr` 共享）分配一块额外的内存。
- **make_shared 方式**：会一次性分配一块连续的内存，同时容纳两部分内容：
  - 对象本身的数据（`T` 类型的实例）。
  - 引用计数（以及 `shared_ptr` 所需的其他控制信息，如删除器等）。
2. **提高异常安全性**：在需要将指针作为参数传递等场景下，使用 `make_shared` 可以避免因异常抛出导致的内存泄漏风险。
3. **简化代码**：无需显式使用 `new` 操作符，直接通过 `make_shared<类型>(构造参数)` 的形式即可创建智能指针，使代码更简洁。

### 3.1.4 weak_ptr
## 3.2 `lambada`表达式

# 四、设计模式
## 4.1 单例模式：✅
### 4.1.1 单例模式实现方式之一：
1. 私有化构造函数，删除拷贝构造函数，删除复制运算符函数
2. 提供全局访问点：
    - 实现返回类唯一实例的静态成员函数`getInstance()`
    - 函数内初始化一个局部静态成员变量`instance`
    - 函数返回局部静态成员变量`instance`的引用

```cpp
class Singleton {
private:
  Singleton() = default; // 构造函数私有化,并且使用默认实现
  Singleton(const Singleton &a) = delete;            // 删除拷贝构造
  Singleton &operator=(const Singleton &a) = delete; // 删除复制运算符函数
public:
  static Singleton& getInstance() {
    static Singleton instance;
    return instance;
  }
};
```
### 4.1.2 单例模式注意事项
1. **类的静态成员变量需要在类外进行初始化**。若是使用*返回唯一实例指针*的方式来实现单例模式的化需要在类内定义静态成员指针并在类外初始化
2. **类的静态成员函数默认情况下只能操作静态成员变量**。因为静态成员函数不属于类分身，若要操作非静态成员可以向函数内传实例或者this指针

### 4.1.3 单例模式线程安全问题
1. 上述代码在**C++11标准及以上**是线程安全的。因为 C++11 规定，静态局部变量的初始化会在首次访问时进行，且编译器会自动加入同步机制，确保即使多线程同时调用`getInstance()`，也只会初始化一次实例。因此确实能保证全局唯一。
2. "返回指针的实现是否线程安全"需要分情况讨论：
    - 饿汉式：在程序启动时就初始化静态实例，如`static Singleton* instance = new Singleton();`，返回指针的方式也是线程安全的
    - 懒汉式：首次调用时才初始化，如`if (instance == nullptr) { instance = new Singleton(); }）`，且未加锁，则不是线程安全的
3. 即使类对象的创建是线程安全的，对于类内的普通成员来讲，在多线程访问操作时依旧会发生数据竞争的问题
# 五、并发组件
## 5.1 线程池
# 六、计算机网络
需要熟悉`HTTP`,`TCP`,`UDP`,`IP`等协议以及收集面试中常见的问题，对于`TCP`,`UDP`还要知道他们的编程实现。对于`OSI`中的应用层、传输层、网络层等其他知识也需要了解
## 6.1 UDP
## 6.2 TCP
## 6.3 HTTP
## 6.4 IP
# 七、数据库
学会SQL数据库常见的增删查改操作
# 八、常见开发工具的命令
## 8.1 Linux常用命令
## 8.2 git常用命令
### 8.2.1 git init
初始化新的 Git 仓库
- 常用参数/用法
    - `git init`：在当前目录创建一个新的、空的 Git 仓库
    - `git init /path/to/your/project`：在`/path/to/your/project`创建一个新的、空的 Git 仓库
    - `git init -b main`：初始化仓库，并设置默认分支为 'main'
    - `git init --bare /srv/my-project.git`：创建裸仓库，保证团队协作和自动化流程的可靠性与一致性。
### 8.2.1 git add
将文件添加到暂存区
- 基本用法：`git add <文件/目录>`
- 常用参数 / 用法：
    - `git add .`：添加**当前目录**所有修改到暂存区
    - `git add --all` 或 `-A`：添加**整个 Git 仓库中**所有的修改到暂存区
    - `git add -u`：只添加已跟踪文件的修改和删除（不包括新增文件）
    - `git add src/`：添加整个目录的修改
    - `git add README.md`：添加单个文件
## 8.3 Cmake常用命令
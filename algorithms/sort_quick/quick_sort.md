# 快速排序知识点
## 实现思路
1. 选择基准值（pivot）：
    - 从待排序数组中选取一个元素作为基准值（常见选择有首元素、尾元素、中间元素或随机元素）。
2. 分区（partition）：
    - 重新排列数组，使所有小于基准值的元素移到基准值左侧，所有大于基准值的元素移到右侧（等于基准值的元素可放任意一侧）。
    - 分区结束后，基准值处于其在最终有序数组中的正确位置。
3. 递归排序子数组：
    - 对基准值左侧的子数组（元素均小于基准值）和右侧的子数组（元素均大于基准值）分别重复上述 “选择基准值 - 分区” 过程。
    - 递归终止条件：子数组长度为 0 或 1（已天然有序）。
## 时间复杂度
1. 平均情况：O (n log n)，这是快速排序的典型表现，源于其分治策略将问题规模不断二分。
2. 最坏情况：O (n²)，发生在每次选择的基准值都是当前子数组中的最大或最小元素时（如对已排序数组选择首 / 尾元素作为基准），导致分区失衡，递归深度变为 n 层。
3. 最好情况：O (n log n)，当每次选择的基准值都能将数组均匀分为两个规模接近的子数组时。
## 空间复杂度
1. 额外空间复杂度：O (log n) ~ O (n)，主要来自递归调用产生的栈空间。
2. 平均情况下，递归深度为 log n，空间复杂度为 O (log n)。
3. 最坏情况下，递归深度为 n，空间复杂度为 O (n)。
## 代码实现
```cpp
int partition(std::vector<int> &arr, int low, int high) {
  int pivot = arr[high]; //  设置最后的为基准值
  int i = low - 1;       // 小于基准值的数据的最大索引
  for (int j = low; j < high; j++) {
    if (arr[j] <= pivot) {
      i++;
      std::swap(arr[j], arr[i]);
    }
  }
  std::swap(arr[i + 1], arr[high]);
  return i + 1; 
  // 本轮已经将小于基准值的元素移动到索引i及i以前的位置，再将基准值交换到i+1处即可
}

void quickSort(std::vector<int> &arr, int low, int high) {
  if (low < high) {
    int pi = partition(arr, low, high);  //将arr分区并返回新的基准值
    quickSort(arr, low, pi - 1);    //递归调用
    quickSort(arr, pi + 1, high);
  }
}
```
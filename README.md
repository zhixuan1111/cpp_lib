# 说明
根据简历中提到的知识点自己实现一番，并且将**相应的知识点**和**常见面试问题**进行总结。主要分为八个部分，算法、容器、C++新特性、设计模式、并发组件、计算机网络、数据库、常用开发工具命令。最后总结成一个综合性的文档，用于面试辅助。
# 一、算法
## 1.1 查找算法：
- 二分查找：✅
- 线性查找：✅
## 1.2 排序算法
- 冒泡排序：✅
- 快速排序：✅
- 归并排序：✅
- 堆排序
## 1.3 二叉树
# 二、容器
## 2.1 vector：✅
### 2.1.1 vector实现方式
1. vector是一个函数模板类，内部由`T* data`，`size_t capacity`，`size_t size`组成，三个参数的含义分别是：
    - `data`：管理`T`类型的一块内存地址，大小为`capacity`；
    - `size`：当前数组中存放的元素个数。
2. 构造函数实现
    - `vector()`：默认构造函数。构造一个空的 vector，不包含任何元素。
    - `vector(size_t size)`：指定大小的构造函数。构造一个包含 n 个元素的 vector，每个元素使用默认值初始化（对于基本类型通常是 0）。
    - `vector(size_t size,T value)`：指定大小和初始值的构造函数。构造一个包含 n 个元素的 vector，每个元素都被初始化为指定值 value。
    - 还有迭代器范围构造函数、拷贝构造函数、移动构造函数（C++11 起）、初始化列表构造函数、分配器构造函数
### 2.1.2 vector相关面试问题
1. `vector`的扩容机制是什么？
    - `vector` 底层使用连续的动态数组存储元素，当现有容量不足以容纳新元素时，会触发扩容
    - 分配一块更大的新内存（通常是当前容量的 1.5~2 倍）
    - 将旧内存中的元素复制 / 移动到新内存
    - 释放旧内存
    - 指向旧内存的迭代器、指针、引用会失效
1. `push_back()`和`emplace_back()`有什么区别？`emplace_back()`是怎么实现的？
    - `push_back()`：
        用于将一个已经构造好的对象复制或移动到容器中。
        如果传入的是临时对象，会先构造临时对象，再通过移动构造函数将其移动到容器（C++11 及以后）；如果传入的是已有对象，则会调用复制构造函数。
    - `emplace_back()`：
        直接在容器的内存空间中原地构造对象，避免了临时对象的创建和移动 / 复制操作。
        它接收的是对象构造函数的参数，而非对象本身，通过这些参数直接在容器末尾构造新元素。
## 2.2 list：✅
## 2.3 hash table：✅
## 2.4 deque

# 三、C++新特性
需要了解的新特性有智能指针、`lambada`表达式
## 3.1 智能指针
### 3.1.1 unique_ptr
### 3.1.2 shared_ptr
### 3.1.3 weak_ptr
## 3.1 `lambada`表达式

# 四、设计模式
## 4.1 单例模式：✅
### 4.1.1 单例模式实现方式之一：
1. 私有化构造函数，删除拷贝构造函数，删除复制运算符函数
2. 提供全局访问点：
    - 实现返回类唯一实例的静态成员函数`getInstance()`
    - 函数内初始化一个局部静态成员变量`instance`
    - 函数返回局部静态成员变量`instance`的引用

```cpp
class Singleton {
private:
  Singleton() = default; // 构造函数私有化,并且使用默认实现
  Singleton(const Singleton &a) = delete;            // 删除拷贝构造
  Singleton &operator=(const Singleton &a) = delete; // 删除复制运算符函数
public:
  static Singleton& getInstance() {
    static Singleton instance;
    return instance;
  }
};
```
### 4.1.2 单例模式注意事项
1. **类的静态成员变量需要在类外进行初始化**。若是使用*返回唯一实例指针*的方式来实现单例模式的化需要在类内定义静态成员指针并在类外初始化
2. **类的静态成员函数默认情况下只能操作静态成员变量**。因为静态成员函数不属于类分身，若要操作非静态成员可以向函数内传实例或者this指针

### 4.1.3 单例模式线程安全问题
1. 上述代码在**C++11标准及以上**是线程安全的。因为 C++11 规定，静态局部变量的初始化会在首次访问时进行，且编译器会自动加入同步机制，确保即使多线程同时调用`getInstance()`，也只会初始化一次实例。因此确实能保证全局唯一。
2. "返回指针的实现是否线程安全"需要分情况讨论：
    - 饿汉式：在程序启动时就初始化静态实例，如`static Singleton* instance = new Singleton();`，返回指针的方式也是线程安全的
    - 懒汉式：首次调用时才初始化，如`if (instance == nullptr) { instance = new Singleton(); }）`，且未加锁，则不是线程安全的
3. 即使类对象的创建是线程安全的，对于类内的普通成员来讲，在多线程访问操作时依旧会发生数据竞争的问题
# 五、并发组件
## 5.1 线程池
# 六、计算机网络
需要熟悉`HTTP`,`TCP`,`UDP`,`IP`等协议以及收集面试中常见的问题，对于`TCP`,`UDP`还要知道他们的编程实现。对于`OSI`中的应用层、传输层、网络层等其他知识也需要了解
## 6.1 UDP
## 6.2 TCP
## 6.3 HTTP
## 6.4 IP
# 七、数据库
学会SQL数据库常见的增删查改操作
# 八、常见开发工具的命令
## 8.1 Linux常用命令
## 8.2 git常用命令
### 8.2.1 git init
初始化新的 Git 仓库
- 常用参数/用法
    - `git init`：在当前目录创建一个新的、空的 Git 仓库
    - `git init /path/to/your/project`：在`/path/to/your/project`创建一个新的、空的 Git 仓库
    - `git init -b main`：初始化仓库，并设置默认分支为 'main'
    - `git init --bare /srv/my-project.git`：创建裸仓库，保证团队协作和自动化流程的可靠性与一致性。
### 8.2.1 git add
将文件添加到暂存区
- 基本用法：`git add <文件/目录>`
- 常用参数 / 用法：
    - `git add .`：添加**当前目录**所有修改到暂存区
    - `git add --all` 或 `-A`：添加**整个 Git 仓库中**所有的修改到暂存区
    - `git add -u`：只添加已跟踪文件的修改和删除（不包括新增文件）
    - `git add src/`：添加整个目录的修改
    - `git add README.md`：添加单个文件
## 8.3 Cmake常用命令